package ai.idealistic.vacan.abstraction.check.implementation.world.exploits;

import ai.idealistic.vacan.abstraction.Enums;
import ai.idealistic.vacan.abstraction.check.CheckRunner;
import ai.idealistic.vacan.abstraction.event.PlayerAttackEvent;
import ai.idealistic.vacan.abstraction.protocol.PlayerProtocol;
import ai.idealistic.vacan.utils.minecraft.entity.PlayerUtils;
import org.bukkit.event.block.BlockBreakEvent;
import org.bukkit.event.entity.EntityToggleGlideEvent;
import org.bukkit.event.player.PlayerMoveEvent;

public class Exploits extends CheckRunner {

    public final ExploitsElytra elytra;
    private final ExploitsMovement movement;
    private final ExploitsBackTrack backTrack;

    public Exploits(Enums.HackType hackType, PlayerProtocol protocol) {
        super(hackType, protocol);
        elytra = new ExploitsElytra(this);
        movement = new ExploitsMovement(this);
        backTrack = new ExploitsBackTrack(this);
    }

    @Override
    public void handleInternal(boolean cancelled, Object object) {
        if (object == null) {
            movement.run();
        } else if (PlayerUtils.elytra
                && object instanceof EntityToggleGlideEvent) {
            elytra.runPacket();
        } else if (object instanceof PlayerMoveEvent) {
            movement.update();
        } else if (object instanceof BlockBreakEvent) {
            if (!((BlockBreakEvent) object).isCancelled()) {
                movement.onBreak();
            }
        } else if (object instanceof PlayerAttackEvent) {
            backTrack.run((PlayerAttackEvent) object);
        }
    }

}